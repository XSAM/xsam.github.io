[{"categories":null,"content":"As Docker Desktop updated its license to Docker Subscription Service Agreement and is no longer free for professional use, I decided to find alternatives for Docker Desktop on macOS. This is a convenient note for me to check steps without logging personal stuff on my work computer. I hope it can help you too. The goal is to replace Docker Desktop without changing my current workflow. Since I don’t use docker GUI, I only need to replace the VM layer and keep the docker CLI. So, as the VM layer, I use Colima - container runtimes on macOS. ","date":"2023-08-25","objectID":"/posts/docker-desktop-alternatives-for-macos/:0:0","series":null,"tags":["Docker","Docker Desktop","macOS","ARM64","Colima"],"title":"Docker Desktop alternatives for macOS","uri":"/posts/docker-desktop-alternatives-for-macos/"},{"categories":null,"content":"Installation Install Colima with Homebrew: brew install colima Then, manually install the docker Compose plugin, as Colima doesn’t include it. DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker} mkdir -p $DOCKER_CONFIG/cli-plugins curl -SL https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-darwin-aarch64 -o $DOCKER_CONFIG/cli-plugins/docker-compose chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose ","date":"2023-08-25","objectID":"/posts/docker-desktop-alternatives-for-macos/:1:0","series":null,"tags":["Docker","Docker Desktop","macOS","ARM64","Colima"],"title":"Docker Desktop alternatives for macOS","uri":"/posts/docker-desktop-alternatives-for-macos/"},{"categories":null,"content":"Setup container runtime The default VM created by Colima has 2 CPUs, 2GiB memory, which is not enough for me as I run projects on Kubernetes. So, to avoid hanging the container runtime, I created a new VM with 6 CPUs and 8GiB memory. colima start --cpu 6 --memory 8 Then, I created a soft link to Colima’s Unix socket for the docker (this may require root permission) to have a better experience, as it is not easy for some applications to change the default docker socket path. ln -s $(docker context inspect colima -f '{{.Endpoints.docker.Host}}' | sed -e 's/unix:\\/\\///') /var/run/docker.sock ","date":"2023-08-25","objectID":"/posts/docker-desktop-alternatives-for-macos/:2:0","series":null,"tags":["Docker","Docker Desktop","macOS","ARM64","Colima"],"title":"Docker Desktop alternatives for macOS","uri":"/posts/docker-desktop-alternatives-for-macos/"},{"categories":null,"content":"Test the setup docker info docker compose version ","date":"2023-08-25","objectID":"/posts/docker-desktop-alternatives-for-macos/:3:0","series":null,"tags":["Docker","Docker Desktop","macOS","ARM64","Colima"],"title":"Docker Desktop alternatives for macOS","uri":"/posts/docker-desktop-alternatives-for-macos/"},{"categories":null,"content":"最近入手了一个 Yubikey，其中用来做 SSH 登录。一路操作下来，踩不少坑，等到终于使用 Yubikey 中的 Authentication key 登录上机器后发现： 我好像没法拿着这个 Yubikey 随便找台机器登录呀（并不包括 Windows）。 Yubikey 自带 key 的这个优势（杂耍）体现不出来呀，总不能到处登录笔记软件吧。 所以为了满足能随便找台机器都能登录这一需求（伪），特此写（水）一篇文章，介绍一下如何使用 Yubikey SSH 登录机器。 ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:0:0","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"准备工作 配置好 OpenPGP 功能的 Yubikey 没有配置好的同学可以参照这篇文章：YubiKey4 我踩过的那些坑 写得相当详细了。（广告费后台结一下） 随便找到的使用 *nix 操作系统的机器 安装好 GnuPG 套件 ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:1:0","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"布置马戏团 把这段脚本放到 shell profile 中： # GPG ssh support export GPG_TTY=$(tty) gpg-connect-agent updatestartuptty /bye unset SSH_AGENT_PID export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket) function gpg_ssh_clear() { keys=$(gpg-connect-agent 'keyinfo --ssh-list --ssh-fpr' /bye | grep KEYINFO | awk '{print $3}' | head) for key in $keys; do gpg-connect-agent \"delete_key $key --force\" /bye; done } gpg-agent 有模拟 OpenSSH agent 的功能，所以可以用 gpg-agent 替代 ssh-agent，设置 SSH_AUTH_SOCK 和 SSH_AGENT_PID 以达成目的。 使用 gpg-agent cache SSH key 后，ssh-add -D 将不再起作用，如果需要删除 gpg-agent cache 的 key，得使用 gpg-connect-agent。所以我写了个函数，拿出所有的 gpg-agent cache 的 SSH key，并删除。想清理时，执行 gpg_ssh_clear 即可。（并不会清除 Yubikey 里面的 key） 添加内容到 ~/.gnupg/gpg-agent.conf 文件中： enable-ssh-support write-env-file use-standard-socket default-cache-ttl 600 max-cache-ttl 7200 pinentry-program 这边给出的是 macOS 的示例，其他的 OS 可以参考这个回答。 ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:2:0","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"拿到表演钥匙 输入 gpgconf --reload gpg-agent 重载配置，插上 Yubikey，GnuPG 会自动检测到并把 key 加入到 agent 里面。 接着 ssh-add -L 就能看到一个备注为 cardno:card-id 或 openpgp:key-id 的 SSH pubilc key 了。 ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:3:0","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"杂耍 找台机器（或者可以 ssh 自己），公钥一丢，直接 ssh 走起，输入 Yubikey PIN 后，直接就登录上去了。 完全不需要把 private key 复制到机器上冒着泄漏的风险，想在哪登，就在哪登。（所以我为啥不出门自带机器。。。（这不重要！）） ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:4:0","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"抛 12 个球！ 如果希望让整个 SSH 授权过程更为庄重（增加节目效果），你可以在授权前要求触碰 Yubikey 才能完成授权。 通过安装官方的 ykman 设置： ykman openpgp set-touch aut on 这样每次 ssh 用到 Yubikey 的 key 授权时，Yubikey 的指示灯都会一闪一闪表示需要触碰才能完成操作。 When the yubikey is pressed, then you have my permission to die (authenticate) – Bane ( ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:4:1","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"还有一件事 目前这个方案用户体验上有个不舒服的地方，每次 ssh-add 添加普通的 SSH key 的时候，GPG 都会跳出来要求一个密码用来保护加入的 SSH secret key。好在添加 SSH key 不算是高频操作，所以也还能接受。 ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:5:0","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"GPG snippets 放上一些 GPG snippet，方便查阅。 # Reload gpgconf --reload gpg-agent # Kill gpgconf --kill gpg-agent # List options gpgconf --list-options gpg-agent # This is an undocumented command to export ssh public key pgp --export-ssh-key \u003cKey ID\u003e # Quickly start gpg-agent gpg-connect-agent /bye ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:5:1","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":null,"content":"参考 https://wiki.archlinux.org/index.php/GnuPG#SSH_agent https://blog.dwx.io/yubikey4 https://florin.myip.org/blog/easy-multifactor-authentication-ssh-using-yubikey-neo-tokens https://github.com/Yubico/yubikey-manager ","date":"2020-01-03","objectID":"/posts/yubikey-with-ssh/:6:0","series":null,"tags":["Yubikey","GPG","SSH"],"title":"Yubikey with SSH","uri":"/posts/yubikey-with-ssh/"},{"categories":["Programming"],"content":"上次简单介绍了 tmux 的一些基本概念和用法，能让我们很快的上手使用。但想用的顺手我认为还需要做些改进。 所以，本篇主要分享自己目前在用的 tmux 配置，并附上详细说明原因，自己以后查阅也方便。 ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:0:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"在分享前 先介绍几个概念，tmux 中有几种常见配置： 快捷键(key)：可以通过 bind-key 命令来配置，比如 tmux bind-key S choose-tree 意思是绑定 S 用来触发 choose-tree 这个 tmux 命令（当然，要先按 prefix key ），效果和直接再 tmux session 中输入 tmux choose-tree 是一样的。 变量(option)：比如 tmux set-option history-limit 10000 是设置 tmux 的历史长度 这些配置都可以放到 ~/.tmux.conf 这个文件下，tmux 第一次启动时，会加载这些配置。 在运行 tmux 时，可以通过 prefix key + :，然后输入 source-file ~/.tmux.conf 手动重新加载配置。不过呢，和 shell 一样，tmux 加载配置只是修改配置中对于的变量，对于旧的没被覆盖的配置，还是会在的。 所以有时候我会 tmux kill-server 直接杀掉 tmux 进程，再重新打开 tmux 来保证配置加载的完整性。 放一张配置完的图，也是上一篇的第一张图 ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:1:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"开始吧 ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:2:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"开胃菜 # Common config set-option -g set-titles on set-option -g set-titles-string \"#S / #W\" tmux 默认不会改 Terminal 的 title，所以在终端软件的 tab 名字里面只有 “tmux”，这对于同时要开很多个 tab 的人来说很不友好。所以我开启了 title ，并把它的格式改为 当前 session 名字 / 当前 window 名字 set-option -g repeat-time 1000 # default is 500 tmux 在执行连续的快捷键时（比如切换 pane ），默认只有 500ms 的等待时间，超过这个时间，就会退回到正常输入模式，有时候稍微按得慢一点（也可能是我手残），就要重新按 prefix key 来重新输入快捷键，所以我把他改为 1s 。 set-option -g history-limit 10000 默认的历史行数比较小，改大一点，看程序日志的时候不至于被吃掉。（有时候我会吧 tmux 当成临时的 supervisor 进程管理解决方案） # Terminal type configuration set-option -g default-terminal \"screen-256color\" set-option -ga terminal-overrides \",xterm-256color:Tc\" tmux 中的颜色可能和 shell 中的有所偏差，使用如上设置使得颜色能正常显示。 ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:2:1","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"副菜 作为 Vim 党，当然希望 tmux 中也能用到一些 Vim 类的快捷键。 set-window-option -g mode-keys vi 这样就可以在滚动模式（copy-mode）中，使用一些 Vim 键位了。 不过我觉得这还不够 Vim ，还需要进一步的设置。 # Move \u0026 Copy while scrolling bind-key -T copy-mode-vi v send-keys -X begin-selection bind-key -T copy-mode-vi y send-keys -X copy-selection-and-cancel bind-key -T copy-mode-vi u send-keys -X halfpage-up bind-key -T copy-mode-vi d send-keys -X halfpage-down 浏览历史的时候，可以用 v 选择，y 复制，u/d 翻页。 # Select pane bind-key -r j select-pane -D bind-key -r k select-pane -U bind-key -r h select-pane -L bind-key -r l select-pane -R 使用 j,k,h,l 来选择 pane 。 bind-key -r M-j resize-pane -D bind-key -r M-k resize-pane -U bind-key -r M-h resize-pane -L bind-key -r M-l resize-pane -R bind-key -r M-J resize-pane -D 5 bind-key -r M-K resize-pane -U 5 bind-key -r M-H resize-pane -L 5 bind-key -r M-L resize-pane -R 5 使用 Meta + j,k,h,l 来调整 pane 大小（如果使用 iTerm 的话，可能需要把 Option 键位设置成，Esc+ 键） ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:2:2","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"主食 显示当前运行程序 程序输出日志多了，不清楚当前执行的程序是什么了？ # Pane border set-option -g pane-border-status top # Show current cmd if-shell \"uname | grep -q Darwin\" \\ \"set-option -g pane-border-format ' #P: #(sleep 0.25; ps -t #{pane_tty} -o args= | tail -n 1) '\" if-shell \"uname | grep -q Linux\" \\ \"set-option -g pane-border-format ' #P: #(sleep 0.25; ps -t #{pane_tty} -o args= --sort=etime | head -n 1) '\" 我的方案是打开 pane 的 title ，然后把 title 设置为当前执行的程序 cmd 。 原理为使用 ps 命令显示当前 tty 下执行的进程，并显示 cmd 。 然而，这可能会打出多个进程，因为进程和它的子进程会被同时打印出来。比方说用 bash 执行了一个 shell 脚本，脚本内容如下： sleep 3600 如果只显示父进程，那么结果是 bash foo.sh，并不能清楚知道脚本执行到哪了，我希望看到的是 sleep 3600，所以需要根据 ps 得到的结果，来获取子进程的 cmd 。 由于平台不一样 ps 的实现也是不一样的。经过测试，macOS 和 linux 的 ps 打印出来的子进程顺序是相反的，所以两个平台要区分开来对待：Darwin 内核（也就是 macOS 的内核）的用 tail -n 1，linux 内核用 head -n 1 来获取子进程的 cmd 。 关于命令中的 sleep 0.25 主要是因为，有时候会出现 title 失效不更新的情况，加入该命令可以极大的减少该情况的出现。 快速切换 session 同时打开的 session 有点多时，会很不方便切换。虽然 tmux 提供了 prefix key + s 来显示所有的 session 并且可以用方向键来选择切换。 但还是不够好用，我想要的是像 Context 一样的通过用 session name 来切换的功能，并且提供 fuzzy search，并在我打错字个别字时也能正常切换。 这样我只要知道 session name ，闭着眼睛也能切换 session ，不用盯着屏幕看，不用在意 session 的排序位置。 这个功能依赖 fzf 中的 fzf-tmux 程序 bind-key s run-shell \"tmux list-sessions -F \\\"##S\\\" | fzf-tmux | xargs tmux switch -t; true\" bind-key S choose-tree -s 按下 prefix key + s ，你将会看到 tmux 跳出一个额外的 pane ，上面显示了所有的 session name。 你可以通过方向键选择，也可以直接输入 session name，回车即可跳转到该 session 。 有时候 tmux 自带的 choose-tree 也挺有用的，所以我把它的键位移到到了 prefix key + S 。 ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:2:3","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"沙拉 tmux 滚动模式的坑 tmux 在进入 copy mode （查看 pane 历史）时，会暂停读取在 pane 中运行的 tty 的 stdout 和 stderr ，如果 tty 中的程序继续往标准输出中写入，那么操作系统的 tty 缓存最终会被填满。此时程序再写入时，为避免缓冲区溢出，操作系统会会阻塞该 IO 操作。此时该程序很有可能被阻塞，假如这个程序是个提供 web 服务的 server，那么它将停止响应所有的请求。 目前 tmux 官方没有打算解决这个问题（可能是 tmux 实现原因），但有方法可以绕过这个坑。 Show history as scrollable view bind-key F capture-pane -S -10000 -b capture\\; show-buffer -b capture\\; send-keys G\\; delete-buffer -b capture 原理是捕获当前历史，保存到 tmux buffer 中，然后再显示 buffer 的内容。这个方案和 copy mode 的区别就是会丢失 shell 中的颜色。（tmux show-buffer 命令不支持显示颜色） 保存历史到文件 tmux 中的历史不能像普通的 shell 一样，可以通过滚动终端类软件的自带的历史记录来截取日志，假如要截取的日志很长一段，没法直接在一个页面中打印出来怎么办？ bind-key P command-prompt -p 'save history to filename:' -I '~/tmux.history' 'capture-pane -S -10000 -b capture ; save-buffer -b capture %1 ; delete-buffer -b capture' 按下 prefix key + P 即可把历史记录保存到文件中，然后想怎么分析就怎么分析 xD 。 ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:2:4","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"甜点 继承当前目录 打开一个新的 pane 或 window ，当前目录不会继承自上一个 pane ，每次都会在用户目录，挺不方便的。 # -- Split with current direcotry -- # Split panes horizontal bind-key '%' split-window -h -c '#{pane_current_path}' # Split panes vertically bind-key '\"' split-window -v -c '#{pane_current_path}' # Create new window bind-key c new-window -c '#{pane_current_path}' 插件管理 tpm 是 tmux 中的插件管理器，可以用来安装管理自己喜欢的 tmux 插件，非常方便。 安装 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 推荐些我用的插件 # =---- Plugins ----= set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' set -g @plugin 'XSAM/tmux-themepack' # Continuous saving tmux environments set -g @plugin 'tmux-plugins/tmux-resurrect' # set -g @plugin 'tmux-plugins/tmux-continuum' # =---- Plugins ----= # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run -b '~/.tmux/plugins/tpm/tpm' tmux-plugins/tmux-sensible：帮你配置了一些常规的设置 XSAM/tmux-themepack: 我改的主题（自认为还挺好看的 xD) tmux-plugins/tmux-resurrect: 能保存 tmux 的 session 结构，这样关机重启之后，能马上恢复 ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:2:5","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"咖啡、茶 我维护了一个叫 kind-lazy 的项目，提供一些程序的快速安装脚本，其中也有本文提到的 tmux 配置。 快速安装 tmux ： git clone https://github.com/XSAM/kinda-lazy.git cd kinda-lazy/tmux bash lazy_install.sh 喜欢的话可以给项目点个 Star 🚀 Enjoy! ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:2:6","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"Ref http://man.openbsd.org/OpenBSD-current/man1/tmux.1 https://stackoverflow.com/questions/13924365/rails-freezes-when-searching-through-tmux-output-buffer https://github.com/tmux/tmux/issues/431 https://unix.stackexchange.com/questions/26548/write-all-tmux-scrollback-to-a-file https://github.com/junegunn/fzf/blob/master/bin/fzf-tmux ","date":"2019-02-23","objectID":"/posts/tmux-guide-2/:3:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（二）","uri":"/posts/tmux-guide-2/"},{"categories":["Programming"],"content":"用了 tmux 有一段时间了，特别的喜欢这个软件。平时工作中不仅会用它来进行大量的分屏操作，远程连接时意外断开，还能保持原有的工作不被打算。 会话的快速切换也能在需要管理多个项目时让整个流程变得非常的顺畅。在快速切换这方面 tmux 就像是终端中的窗口管理软件，对应到图形界面好比 macOS 下的窗口切换软件 Context。（稍微改造一番后，甚至连操作都很像） ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:0:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"那么，什么是 tmux 呢？ tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. tmux may be detached from a screen and continue running in the background, then later reattached. tmux 主要提供两个功能：会话管理（Session Management） 和 窗口管理（Window Management） 。 会话管理 可以让你管理多个 tty ，tmux 会让这些 tty 始终保持运行，直到被手动关闭或 tmux server 被 kill。在 ssh 一台远程机器的时候极为有用，ssh 连接意外断开时，tmux 中的 tty 不会受到影响而停止当前工作，当重新 ssh 连接上来时，还能继续工作。 窗口管理 可以让你以多种方式显示 tty ，比如每个窗口都有不同的 tty ，切换窗口的时候显示的 tty 也会一起切换。 如果你熟悉 Screen 的话，你可以把 tmux 当成是 Screen 的加强版（至少我是这么认为的 hhhh）。 ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:1:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"概念 先介绍几个小概念可以方便我们理解 tmux ：session, window, pane session: 是一堆 tty 的集合。一个 session 下可以有多个 window 。 window: 会占据一整个终端显示。而一个 window 可以被切分为多个 pane 。 pane: 每个 pane 都是一个 tty 。 tmux session 然后，每个 tmux 都可以连接到同一个 session ，甚至可以同时操作。（在同一开发机上的话，简直是结对编程神器呀） ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:2:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"开始吧 ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:3:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"安装 我会用一些比较新的功能，用的版本是 tmux 2.8（其实 2.6 以上即可），所以虽然 tmux 可以从包管理工具里面直接安装，但我一般选择自己编译。 # Install compile tmux dependencies sudo apt install -y autotools-dev automake libevent-dev ncurses-dev # Install tmux 2.8 TMUX_VERSION='2.8' cd /tmp curl -L https://github.com/tmux/tmux/releases/download/$TMUX_VERSION/tmux-$TMUX_VERSION.tar.gz -o tmux-$TMUX_VERSION.tar.gz tar zxvf tmux-$TMUX_VERSION.tar.gz cd tmux-$TMUX_VERSION ./configure \u0026\u0026 make sudo make install 这样，就安装好了，试着输入 tmux -V 看看版本吧。 ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:3:1","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"玩耍时间！ 创建 session 首先，让我们先创建一个新的 session ，直接输入 tmux 即可快速的创建一个 session 。在出现的界面下方会出现一个状态栏，会有当前时间，hostname，当前窗口之类的信息（具体显示什么信息是可以配置的，tmux 很灵活，完全可以根据自己的喜好来设置） 创建 pane 然后我们可以试着切分出一个 pane ，按下 prefix key （默认设置下，tmux 绑定 Ctrl + b 作为 prefix key），松开按键后，按下 \" 会在下方竖直切分出一个新的 pane 。现在我们就有两个 pane 啦。 切换 pane 现在的话我们的光标在刚刚新创建的 pane 里，想回到之前的 pane 里的话，就需要能在不同的 pane 之前切换的快捷键，按下 prefix key + arrow key 即可，在现在这个情况呢，就是按 prefix key + 方向上键。 退出 pane 退出 pane 的方法很简单，相当于关闭一个 tty ，输入 exit 或者 prefix key + x，按 y 确认即可。 创建 window 接下来我们创用 prefix key + c 建一个新的 window 。状态栏中也会显示新的 window 。 切换 window 按 prefix key + n/p 即可切换到 左/右 边的 window 。如果 window 数量比较多呢，那就多按几次（误） 那就按 prefix key + number key 来快速切换，window 的下标会在状态栏中标出。 detach session 逛了一圈之后想退出 tmux ？按 prefix key + d 即可 detach 当前 session 。session detach 会继续在后台执行，当你需要的时候重新 attach 上去，就可以继续工作啦。 ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:3:2","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"tmux cheatsheet 整理了 tmux 常用的一些快捷键，以便快速查阅：（为方便阅读，以下快捷键均忽略 prefix key） session s 列出所有的 session 并能用方向键选择进行切换。 $ 重命名当前 session d detach 当前 session window c 创建新的 window n 切换到右边的 window （next） p 切换到左边的 window （previous） number key 切换到指定的 window \u0026 关闭当前 window pane \" 竖直切分出新的 pane % 水平切分出新的 pane x 关闭当前 pane arrow key 切换到周围的 pane z 当前的 pane 进入全屏模式，再按一次时，退出全屏 meta + arrow key 更改当前 pane 大小 （meta key 也可以当做 option key） : 调出 tmux 命令行（就像 vim 一样），可以输入 tmux 的命令，比如创建一个新的 session 常用的 tmux 命令。 # 列出所有的 session tmux ls # 创建新的 session 并指定名字 tmux new -s \u003csession-name\u003e # attach 到指定的 session 上 tmux attach -t \u003csession-name\u003e tmux a -t \u003csession-name\u003e # kill session tmux kill-session -t \u003csession-name\u003e # 列出当前 tmux 所有的快捷键 tmux list-keys ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:3:3","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"最后 tmux 在默认设置下其实挺够用的了，不过还不是特别的方便。 比如不能像前面提到的 Context 一样可以根据名字快速切换 session ，这在 session 多的时候感受尤为明显。执行程序久了，要怎么知道现在执行的是什么程序呢？这些都需要对 tmux 进行额外的配置。 所以下一篇会介绍如何配置 tmux ，以及我的解决方案，并附上 tmux 的一些坑点。 ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:4:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":"Ref http://man.openbsd.org/OpenBSD-current/man1/tmux.1 https://github.com/tmux/tmux ","date":"2019-02-06","objectID":"/posts/tmux-guide-1/:5:0","series":null,"tags":["tmux"],"title":"tmux 简易指南（一）","uri":"/posts/tmux-guide-1/"},{"categories":["Programming"],"content":" 本文内容来自对 isaacs/Makefile 的翻译、修改和补充。 Hello, 这是个 Makefile 的基础教程。 你将在这学到为什么 make 命令如此受欢迎。尽管它有着奇怪的语法，但实际上它的表达能力强而且高效，应对构建程序任务时它是个强有力的解决方案。 ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:0:0","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"我们开始吧 你需要在含有 Makefile 文件的文件夹中使用 make 命令，也可以使用 make -f \u003cmakefile\u003e 指定不同的文件名。 Makefile 是一堆规则（rules）的集合。每个规则表明了要做的事情，比如 grunt task 或者 npm package.json 之类的。 一条规则的语法如下： \u003ctarget\u003e: \u003cprerequisites...\u003e \u003ccommands\u003e 目标（target）是必需的。前置条件（prerequisites）和命令（commands）都是可选，但两者之间至少存在一个。 下面是一个示例，用 make 命令试试看会发生什么： tutorial: @# todo: have this actually run some kind of tutorial wizard? @echo \"Please read the 'Makefile' file to go through this tutorial\" 一般来说，如果 make 没有指定目标，那么它会选择运行第一个目标，所以在这个情况下输入 make 和 make tutorial 是一样的结果。 默认情况下，命令在执行前命令本身会被先打印出来，这样你就能看到当前是什么命令在运行。虽然这背离了 “success should be silent” 的 UNIX 教条，但不这么做的话，你很难从构建日志中看出当前在执行的命令。 想要关掉这个默认输出的话，我们可以在每条命令前加上 @ 符号。 每条命令都会分别调用 shell，所以如果你在直接在上一个命令中设置了变量，这个变量将不会出现在下一个命令中。你可以试着输入 make var-lost 看下一个示例会发生什么： var-lost: export foo=bar echo \"foo=[$$foo]\" 你可能注意到了刚才的命令中我们用了两个 $，这是因为每行 Makefile 都会被 make 转义后再传入 shell。至于为什么转义 $，下文会有解释~ 我们可以通过在命令结尾加 \\ 来让两个命令同一个 shell 执行，试着输入 make var-kept： var-kept: export foo=bar; \\ echo \"foo=[$$foo]\" 接下来让我们开始加入依赖吧。在这个示例中，我们将会依赖 source.txt 并创建一个新的文件 result.txt： result.txt: source.txt @echo \"building result.txt from source.txt\" cp source.txt result.txt 输入试试看 make result.txt。Oops…我们出现了错误： $ make result.txt make: *** No rule to make target `source.txt', needed by `result.txt'. Stop. 看起来问题来源于我们试图依赖 source.txt 创建 result.txt，但我们没有告诉 make 怎么去拿到 source.txt，而该文件也不在 make 运行的目录下（如果你没有事先创建的话~）。 我们可以加入一个目标作为依赖生成 source.txt： source.txt: @echo \"building source.txt\" echo \"this is the source\" \u003e source.txt 输入 make result.txt 将会先创建 source.txt 然后复制出 result.txt，试着再一次执行 make result.txt，你会发现什么都没发生。因为它的依赖 source.txt 没有发生改变，所以也就没有必要重新构建一次 result.txt。 执行 touch source.txt，并编辑它，你会发现 make result.txt 又会开始重新构建。 试想一下假如我们在一个项目中需要100个 .c 文件，编译成与之相对的 .o 文件，然后把这些 .o 链接到二进制文件中。（这个和将100个 .style 变成 .css，再将他们组合到一起成为 main.main.css）一条一条的创建规则简直就是一场灾难。 好在 make 可以简化这些。通过创建一条通用的规则匹配任何符合模式的文件。然后声明另外一种匹配模式来作转换。 ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:1:0","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"自动变量（Automatic Variables） 我们可以使用一些特殊的语法来适配输入和输出文件。下面是一些自动变量（Automatic Variables），它们的值与当前规则有关： $@ 指代当前的目标，你可以把它当作 shell 脚本中的 $@。@ 就像是 arguments 的首字母 a 一样。当你输入 make foo，foo 就是参数。 $\u003c 指代第一个前置条件。你可以把 \u003c 当作 shell 中的输入管道。就像 head \u003c foo.txt 把 foo.txt 的内容当作输入。 $^ 指代不止是指代第一个前置条件，而是全部的前置条件。你可以把它当作 @^ 来记忆，他们只是方向不一样（\u003c 和 ^ 的区别~）。如果一个文件出于一些原因多次出现在前置条件中，在 $^ 中仍然只会显示一次。 $? 指代比目标新的所有前置条件。$? 就像一个问题，”等一下，为什么你要这么干？什么文件发生了改动？“ $$ 指代字面意思上的 $ 符号，更多的美元符号等于更多的现金等于美元符号（有点拗口） $* 指代 % 符号匹配到的部分。（下面会有示例具体说明） 你也可以使用特殊语法 $(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。$(\u003cD) 和 $(\u003cF) 对于 $\u003c 也是一样的意思。你可以把 D/F 这个技巧用在任何自动变量上。 还有一些其他的自动变量，不过那些变量大多你都用不到，先放在一边。 我们可以用这些变量，拿到我们想要的数据，比如目标和依赖条件的值: result-using-var.txt: source.txt @echo \"buildling result-using-var.txt using the $$\u003c and \\$$@ vars\" cp $\u003c $@ 虽然方便了许多，但比起一个一个的列出它们，我们可以用一点 shell 脚本生成他们，并放入变量中。 ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:1:1","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"函数（Functions） make 提供一些内置函数帮助我们完成更加复杂的任务，这边我们只列出几个，这也是本文例子中会用到或提及的: shell 函数。 用来执行 shell 命令 wildcard 函数。 列出与模式相匹配的路径，像这样 $(wildcard *.c) patsubst 函数。 用于模式匹配的替换，语法为 $(patsubst pattern,replacement,text) 同时，通常情况下你应该使用 $(wildcard src/*.txt) 因为一般来说项目中已经存在这些文件了。不过这是一个教程，而我们想用它来生成文件。 这将会用 shell 生成一个文件名列表: srcfiles := $(shell echo src/{00..99}.txt) 那么我们怎么在 src 文件夹中创建这些文件呢？ 我们可以使用 % 占位符来表示\"所有文件路径为 src/*.txt 格式的文件名\"然后将这些匹配到的文件名会被放入 $* 变量中。 src/%.txt: @# First things first, create the dir if it doesn't exist. @# Prepend with @ because srsly who cares about dir creation @[ -d src ] || mkdir src @# then, we just echo some data into the file @# The $* expands to the \"stem\" bit matched by % @# So, we get a bunch of files with numeric names, containing their number echo $* \u003e $@ 试着运行 make src/00.txt 和 make src/01.txt 看看结果。文件被创建出来了。 不过为了不每个文件都 make 一次，我们应该定义一个\"伪（phony）“目标依赖所有我们需要创建的源文件。（在使用伪目标时，或者依赖它时，make 就不会检查这个目标文件是否真正存在。毕竟如果目录下有个文件和目标相同的话，make 会认为没有必要重新构建，导致不会执行命令。） 这时我们运行 make source 会在 src/ 下创建所有的文件。首先它会把 srcfiles 变量中的路径当作前置条件，接着 src/%.txt 目标会与之匹配。于是便会执行匹配到的目标，创建 src/ 文件夹，并输出匹配的字段到文件中。试着运行 make source 看看结果把: .PHONY: source source: $(srcfiles) 源文件有了，现在是时候创建结果文件了，当然，我们得先创建结果文件夹。可能你想匹配所有的源文件，然后用它来创建结果文件: dest/%.txt: src/%.txt @[ -d dest ] || mkdir dest cp $\u003c $@ 非常好，但这需要我们执行 make dest/#.txt 100次！唔。。我猜应该没人会想这么干。 我们还需要再补充点东西。 看起来我们应该创建一个伪目标依赖所有的结果文件，就像依赖所以的目标文件一样。 这一次我们可以使用内置的 patsubst 函数，它会把所有的源文件路径替换结果标文件路径，这样我们可以不用重建一个结果文件列表（就像 srcfiles 一样）。 destfiles := $(patsubst src/%.txt,dest/%.txt,$(srcfiles)) .PHONY: destination destination: $(destfiles) 既然 destination 不是一个真正的文件名，我们应该把它定义为伪目标。使用.PHONY 声明伪目标是一个好习惯。 现在，让我们把这些结果文件名合在一起\"编译\"把，使用 cat 命令来演示这个效果: kitty: $(destfiles) @# Remember, $\u003c is the input file, but $^ is ALL the input files. @# Cat them into the kitty. cat $^ \u003e kitty 执行 make kitty 看看会发生什么。 每个结果文件都被创建了出来，而且 kitty 文明中出现了每个结果文件的名字。如果再运行 make kitty，它会说 “kitty is up to date”。 如果你像这样 touch src/25.txt; make kitty改动了某个源文件，然后执行 make kitty，神奇的事情出现了! 你会发现 make 很聪明，它只会对更改过的源文件 25.txt 产生反应，重建与之对应的结果文件，并重新\"编译\"到 kitty 中。它不会每次都重写生成源文件，再重新生成结果文件。 在 Makefile 中写一个 test 目标是一个好习惯，因为大家会参与你的项目中，如果你的项目里有 Makefile 的话，他们会希望能用 make test 做一些事情。 当然没有 kitty 的话是不能跑测试的，所以我们需要依赖它: .PHONY: test test: kitty @echo \"miao\" \u0026\u0026 echo \"tests all pass!\" 最后，make clean 需要总是能移除你用 Makefile 创建出来的东西，这样我们就可以移除一些过期的\"坏东西”。 .PHONY: clean clean: rm -rf *.txt src dest kitty 如果出错的话会发生什么事情呢？打个比方你在构建东西，然后一条命令失败了，那么 make 会终止并且拒绝执行接下来的命令，返回一个非零的错误码。 为了示范这个操作，试着执行下面这段\"坏猫猫\"规则，它会退出且返回错误码为1。 .PHONY: badkitty badkitty: $(MAKE) kitty # The special var $(MAKE) means \"the make currently in use\" false # \u003c-- this will fail echo \"should not get here\" ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:1:2","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"有一些补充 ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:2:0","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"make kitty 我把上面提到的一些示例整合到了一起，你可以直接试试 make kitty ~ srcfiles := $(shell echo src/{00..99}.txt) destfiles := $(patsubst src/%.txt,dest/%.txt,$(srcfiles)) src/%.txt: @# First things first, create the dir if it doesn't exist. @# Prepend with @ because srsly who cares about dir creation @[ -d src ] || mkdir src @# then, we just echo some data into the file @# The $* expands to the \"stem\" bit matched by % @# So, we get a bunch of files with numeric names, containing their number echo $* \u003e $@ dest/%.txt: src/%.txt @[ -d dest ] || mkdir dest cp $\u003c $@ .PHONY: source source: $(srcfiles) .PHONY: destination destination: $(destfiles) kitty: $(destfiles) @# Remember, $\u003c is the input file, but $^ is ALL the input files. @# Cat them into the kitty. cat $^ \u003e kitty .PHONY: test test: kitty @echo \"miao\" \u0026\u0026 echo \"tests all pass!\" .PHONY: clean clean: rm -rf src dest kitty ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:2:1","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"赋值符 变量可以指向另外一个变量。 foo = $(bar) Makefile 提供四种赋值符，区别如下: VARIABLE = value 懒惰赋值。在执行的时候递归的获取值。也是赋值默认的行为。 VARIABLE := value 立即赋值。定义变量时就赋好值，不会随着 value 的变更而发生变更 VARIABLE ?= value 为空赋值。如果 VARIABLE 为空，赋值。 VARIABLE += value 追加赋值。将值追加到变量的末尾。 下面是个示例展示他们的区别: foo = \"foo\" a = $(foo) b := $(foo) c ?= $(foo) d += $(foo) d += $(foo) foo = \"bar\" echo: @echo a = $(a) @echo b = $(b) @echo c = $(c) @echo d = $(d) make echo 结果: a = bar b = foo c = bar d = bar bar ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:2:2","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"环境变量 你可以在 Makefile 中直接引入环境变量，也可以定义新的全局环境变量： export FOO=${PATH}:/foo/bin .PHONY: env env: echo $$FOO 这个示例会创建一个全局的环境变量 FOO ，可以在任何命令中使用。不过由于每个命令都是新的 shell ，所以在命令中更改这些环境变量，其他的命令中是看不到更改效果的。 示例中引用的环境变量 PATH 如果不存在于调用 make 的 shell 中，也可以通过 make PATH=\"bar\" env 来指明 PATH 的值。 ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:2:3","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"小坑 Makefile 对 tab 很执着，如果缩进的时候用了空格会报错的哦 Makefile:3: *** missing separator. Stop. 你可以用 cat -e -t -v Makefile 来检查用了空格还是 tab。 test:$ ^I@echo tab$ @echo space$ 命令前面有 ^I 的就是 tab，没有的就是空格。 ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:2:4","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":["Programming"],"content":"还有一件事 想必你已经大致的了解到了 Makefile，以及它能干什么。想进一步了解 Makefile？可以去看看它的官方手册GNU make~ ","date":"2018-04-27","objectID":"/posts/makefile-basic-tutorial/:3:0","series":null,"tags":["Makefile"],"title":"Makefile 基础教程","uri":"/posts/makefile-basic-tutorial/"},{"categories":null,"content":" Copy from 《Hugo 主题 Nuo 文章样式预览》 这篇文章集中说明主题所支持的 Markdown 语法和 Hugo Shortcodes 插件，你也可以在这里预览到他们的样子。如果你不喜欢某些样式，可以去修改 css/ 文件夹下的 .scss 文件。 1.标题 H1 ","date":"2018-01-20","objectID":"/posts/theme-preview/:0:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"H2 ","date":"2018-01-20","objectID":"/posts/theme-preview/:1:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"H3 H4 H5 H6 ","date":"2018-01-20","objectID":"/posts/theme-preview/:1:1","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"2. 段落 使用单引号 * 或者单下划线 _ 标记 斜体强调 或者 斜体强调 使用两个引号 ** 或者两个下划线 __ 标记 加粗强调 或者 加粗强调 引号和下划线可叠加使用 → 只是加粗 斜体并加粗 使用两个波浪线 ~~ 标记 已删除文字 插入文字暂无 Markdown 标记，直接使用 HTML 标签 \u003cins\u003e 标记 插入文字 行内代码使用反引号标记 → print(\"hello world\") 上标 X2 / 下标 X2 按键 Ctrl 外链 chekun’s blog 页面内段落 图片 注意：你可以通过 {#section-id} 方式自定义段落锚点 参考资料 [1][2] ","date":"2018-01-20","objectID":"/posts/theme-preview/:2:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"3. 列表 以下的无序、有序和任务列表均支持二级嵌套，不建议使用二级以上嵌套。 ","date":"2018-01-20","objectID":"/posts/theme-preview/:3:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"3.1 无序列表 无序列表 嵌套的无序列表 嵌套的无序列表 无序列表 嵌套的有序列表 嵌套的有序列表 无序列表 ","date":"2018-01-20","objectID":"/posts/theme-preview/:3:1","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"3.2 有序列表 有序列表 嵌套的有序列表 嵌套的有序列表 有序列表 嵌套的无序列表 嵌套的无序列表 有序列表 ","date":"2018-01-20","objectID":"/posts/theme-preview/:3:2","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"3.3 定义列表 CSS 层叠样式表 ","date":"2018-01-20","objectID":"/posts/theme-preview/:3:3","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"3.4 任务列表 Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票 ","date":"2018-01-20","objectID":"/posts/theme-preview/:3:4","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"4. 引用 野火烧不尽，春风吹又生。 – 白居易《赋得古原草送别》 ","date":"2018-01-20","objectID":"/posts/theme-preview/:4:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"5. 代码 以本站的一段 JavaScript 代码做演示。 // Initialize video.js player if (document.getElementById('my-player') !== null) { /* eslint-disable no-undef */ videojs('#my-player', { aspectRatio: '16:9', fluid: true, }); } ","date":"2018-01-20","objectID":"/posts/theme-preview/:5:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"6. 分割线 中间能写字的分割线，如果你修改了分割线中字的内容，请配合修改 CSS 样式。 ","date":"2018-01-20","objectID":"/posts/theme-preview/:6:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"7. 图片 不带标题的图片，如下图👇 showcase.png 带标题的图片，如下图👇 showcase.png ","date":"2018-01-20","objectID":"/posts/theme-preview/:7:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"8. 表格 使用 Markdown 画的表格，如下表👇 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 ","date":"2018-01-20","objectID":"/posts/theme-preview/:8:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"9. 数学公式 主题使用了 MathJax 开源库来实现对数学公式的支持，使用 $$ 标记。 $$ evidence_{i}=\\sum_{j}W_{ij}x_{j}+b_{i} $$ ","date":"2018-01-20","objectID":"/posts/theme-preview/:9:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"10. 网易云音乐 主题文章中可以轻松插入 网易云音乐 的指定音乐，你可以根据需要将音乐设置为自动播放，在主题目录 layouts/shortcodes 文件夹下的 music.html 对该标签进行定义。 ","date":"2018-01-20","objectID":"/posts/theme-preview/:10:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"11. YouTube 由于不明原因可能无法播放。 ","date":"2018-01-20","objectID":"/posts/theme-preview/:11:0","series":null,"tags":["Started"],"title":"Theme Preview","uri":"/posts/theme-preview/"},{"categories":null,"content":"小伙伴们的链接~ Eric TaoGe Reficul Sakeven realityOne JJY Renlulu Summer Hypo TomWei Ylck Clark Jason ","date":"0001-01-01","objectID":"/links/:0:0","series":null,"tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"关于我 后端开发者一枚，Vim 党 喜欢折腾，上辈子可能是猫 Links ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于我","uri":"/about/"}]